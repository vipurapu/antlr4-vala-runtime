/* vocabularyimpl.vala
 *
 * Copyright 2020 Valio Valtokari <ubuntugeek1904@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/**
 * This class provides a default implementation of the {@link Vocabulary}
 * interface.
 *
 * @author Valio Valtokari
 */
using Antlr4.Runtime.Misc;

public class Antlr4.Runtime.VocabularyImpl : GLib.Object, Vocabulary
{
	private const string[] EMPTY_NAMES = {};

	/**
	 * Gets an empty {@link Vocabulary} instance.
	 *
	 * No literal or symbol names are assigned to token types, so
	 * {@link #get_display_name(int)} returns the numeric value for all tokens
	 * except {@link Token#EOF}.
	 */
	public static VocabularyImpl EMPTY_VOCABULARY { get; default = new VocabularyImpl(EMPTY_NAMES, EMPTY_NAMES, EMPTY_NAMES); }


	private string[] literal_names;

	private string[] symbolic_names;

	private string[] display_names;

	private int max_token_type;

	/**
	 * Constructs a new instance of {@link VocabularyImpl} from the specified
	 * literal, symbolic, and display token names.
	 *
	 * @param literal_names The literal names assigned to tokens, or {{{null}}}
	 * if no literal names are assigned.
	 * @param symbolic_names The symbolic names assigned to tokens, or
	 * {{{null}}} if no symbolic names are assigned.
	 * @param display_names The display names assigned to tokens, or {{{null}}}
	 * to use the values in {{{literal_names}}} and {{{symbolic_names}}} as
	 * the source of display names, as described in
	 * {@link #get_display_name(int)}.
	 *
	 * @see #get_literal_name(int)
	 * @see #get_symbolic_name(int)
	 * @see #get_display_name(int)
	 */
	public VocabularyImpl(string[] literal_names, string[] symbolic_names, string[]? display_names = null)
	{
		this.literal_names = literal_names != null ? literal_names : EMPTY_NAMES;
		this.symbolic_names = symbolic_names != null ? symbolic_names : EMPTY_NAMES;
		this.display_names = display_names != null ? display_names : EMPTY_NAMES;
		// See note here on -1 part: https://github.com/antlr/antlr4/pull/1146
		this.max_token_type =
			Util.max(this.display_names.length,
					 Util.max(this.literal_names.length, this.symbolic_names.length)) - 1;
	}

	/**
	 * Returns a {@link VocabularyImpl} instance from the specified set of token
	 * names. This method acts as a compatibility layer for the single
	 * {{{token_names}}} array generated by previous releases of ANTLR.
	 *
	 * The resulting vocabulary instance returns {{{null}}} for
	 * {@link #get_literal_name(int)} and {@link #get_symbolic_name(int)}, and the
	 * value from {{{token_names}}} for the display names.
	 *
	 * @param token_names The token names, or {{{null}}} if no token names are
	 * available.
	 *
	 * @return A {@link Vocabulary} instance which uses {{{token_names}}} for
	 * the display names of tokens.
	 */
	public static Vocabulary from_token_names(string[] token_names)
	{
		if (token_names == null || token_names.length == 0)
			return EMPTY_VOCABULARY;

		string[] literal_names = Util.array_copy_of<string>(token_names, token_names.length);
		string[] symbolic_names = Util.array_copy_of<string>(token_names, token_names.length);
		for (int i = 0; i < token_names.length; i++)
		{
			string token_name = token_names[i];
			if (token_name == null) {
				continue;
			}

			if (token_name.length != 0)
			{
				unichar first_char = token_name[0];
				if (first_char == '\'')
				{
					symbolic_names[i] = null;
					continue;
				}
				else if (first_char.isupper())
				{
					literal_names[i] = null;
					continue;
				}
			}

			// wasn't a literal or symbolic name
			literal_names[i] = null;
			symbolic_names[i] = null;
		}

		return new VocabularyImpl(literal_names, symbolic_names, token_names);
	}

	public override int get_max_token_type()
	{
		return max_token_type;
	}

	public override string get_literal_name(int token_type)
	{
		if (token_type >= 0 && token_type < literal_names.length)
			return literal_names[token_type];

		return null;
	}

	public override string get_symbolic_name(int token_type)
	{
		if (token_type >= 0 && token_type < symbolic_names.length)
			return symbolic_names[token_type];

		if (token_type == Token.EOF)
			return "EOF";

		return null;
	}

	public override string get_display_name(int token_type)
	{
		if (token_type >= 0 && token_type < display_names.length)
		{
			string display_name = display_names[token_type];
			if (display_name != null)
				return display_name;
		}

		string literal_name = get_literal_name(token_type);
		if (literal_name != null)
			return literal_name;

		string symbolic_name = get_symbolic_name(token_type);
		if (symbolic_name != null)
			return symbolic_name;

		return token_type.to_string();
	}
}
