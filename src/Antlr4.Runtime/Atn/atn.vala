/* atn.vala
 *
 * Copyright 2020 Valio Valtokari <ubuntugeek1904@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
using Antlr4.Runtime.Misc;

/** */
public class Antlr4.Runtime.Atn.ATN : GLib.Object
{
	public const int INVALID_ALT_NUMBER = 0;


	public Gee.List<ATNState?> states { get; default = new Gee.ArrayList<ATNState?>(); }

	/**
	 * Each subrule/rule is a decision point and we must track them so we
	 * can go back later and build DFA predictors for them.  This includes
	 * all the rules, subrules, optional blocks, ()+, ()* etc...
	 */
	public Gee.List<DecisionState> decision_to_state = new Gee.ArrayList<DecisionState>();

	/**
	 * Maps from rule index to starting state number.
	 */
	public RuleStartState[] rule_to_start_state;

	/**
	 * Maps from rule index to stop state number.
	 */
	public RuleStopState[] rule_to_stop_state;


	public Gee.Map<string, TokensStartState> mode_name_to_start_state { get; default =
		new LinkedHashMap<String, TokensStartState>(); }

	/**
	 * The type of the ATN.
	 */
	public ATNType grammar_type { get; protected set; }

	/**
	 * The maximum value for any symbol recognized by a transition in the ATN.
	 */
	public int max_token_type { get; protected set; }

	/**
	 * For lexer ATNs, this maps the rule index to the resulting token type.
	 * For parser ATNs, this maps the rule index to the generated bypass token
	 * type if the
	 * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}
	 * deserialization option was specified; otherwise, this is {{{null}}}.
	 */
	public int[] rule_to_token_type;

	/**
	 * For lexer ATNs, this is an array of {@link LexerAction} objects which may
	 * be referenced by action transitions in the ATN.
	 */
	public LexerAction[] lexer_actions;

	public Gee.List<TokensStartState> mode_to_start_state { get; default = new Gee.ArrayList<TokensStartState>(); }

	/** Used for runtime deserialization of ATNs from strings */
	public ATN(ATNType grammar_type, int max_token_type)
	{
		this.grammar_type = grammar_type;
		this.max_token_type = max_token_type;
	}

	/**
	 * Compute the set of valid tokens that can occur starting in state {{{s}}}.
	 * If {{{ctx}}} is null, the set of tokens will not include what can follow
	 * the rule surrounding {{{s}}}. In other words, the set will be
	 * restricted to tokens reachable staying within {{{s}}}'s rule.
	 */
	public IntervalSet next_tokens(ATNState s, RuleContext ctx = null)
	{
		LL1Analyzer anal = new LL1Analyzer(this);
		IntervalSet next = anal.LOOK(s, ctx);
		return next;
	}

	public void add_state(ATNState? state)
	{
		if (state != null)
	    {
			state.atn = this;
			state.state_number = states.size;
		}

		states.add(state);
	}

	public void remove_state(ATNState state)
	{
		states[state.state_number] = null; // just free mem, don't shift states in list
	}

	public int define_decision_state(DecisionState s)
	{
		decision_to_state.add(s);
		s.decision = decision_to_state.size - 1;
		return s.decision;
	}

    public DecisionState get_decision_state(int decision)
	{
        if (!decision_to_state.is_empty)
            return decision_to_state[decision];

        return null;
    }

	public int number_of_decisions
	{
	    get
	    {
		    return decision_to_state.size;
		}
	}

	/**
	 * Computes the set of input symbols which could follow ATN state number
	 * {{{stateNumber}}} in the specified full {{{context}}}. This method
	 * considers the complete parser context, but does not evaluate semantic
	 * predicates (i.e. all predicates encountered during the calculation are
	 * assumed true). If a path in the ATN exists from the starting state to the
	 * {@link RuleStopState} of the outermost context without matching any
	 * symbols, {@link Token#EOF} is added to the returned set.
	 *
	 * If {{{context}}} is {{{null}}}, it is treated as {@link ParserRuleContext#EMPTY}.
	 *
	 * Note that this does NOT give you the set of all tokens that could
	 * appear at a given token position in the input phrase.  In other words,
	 * it does not answer:
	 *
	 *   "Given a specific partial input phrase, return the set of all tokens
	 *    that can follow the last token in the input phrase."
	 *
	 * The big difference is that with just the input, the parser could
	 * land right in the middle of a lookahead decision. Getting
     * all *possible* tokens given a partial input stream is a separate
     * computation. See [[https://github.com/antlr/antlr4/issues/1428]]
	 *
	 * For this function, we are specifying an ATN state and call stack to compute
	 * what token(s) can come next and specifically: outside of a lookahead decision.
	 * That is what you want for error reporting and recovery upon parse error.
	 *
	 * @param state_number the ATN state number
	 * @param context the full parse context
	 * @return The set of potentially valid input symbols which could follow the
	 * specified state in the specified context.
	 * @throws OptionError if the ATN does not contain a state with
	 * number {{{state_number}}}
	 */
	public IntervalSet get_expected_tokens(int state_number, RuleContext? context) throws OptionError
	{
		if (state_number < 0 || state_number >= states.size)
			throw new OptionError.BAD_VALUE("Invalid state number.");


		RuleContext? ctx = context;
		ATNState s = states[state_number];
		IntervalSet following = next_tokens(s);
		if (!following.contains(Token.EPSILON))
			return following;

		IntervalSet expected = new IntervalSet();
		expected.add_all(following);
		expected.remove(Token.EPSILON);
		while (ctx != null && ctx.invoking_state >= 0 && following.contains(Token.EPSILON))
	    {
			ATNState invoking_state = states[ctx.invoking_state]
			RuleTransition rt = invoking_state.transition(0) as RuleTransition;
			following = next_tokens(rt.follow_state);
			expected.add_all(following);
			expected.remove(Token.EPSILON);
			ctx = ctx.parent;
		}

		if (following.contains(Token.EPSILON))
			expected.add(Token.EOF);

		return expected;
	}
}
