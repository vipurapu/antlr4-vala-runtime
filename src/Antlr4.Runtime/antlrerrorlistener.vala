/* antlrerrorlistener.vala
 *
 * Copyright 2020 Valio Valtokari <ubuntugeek1904@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
using Antlr4.Runtime.Error;
using Antlr4.Runtime.Misc;

/** How to emit recognition errors. */
public interface Antlr4.Runtime.ANTLRErrorListener : ANTLRObject
{
	/**
	 * Upon syntax error, notify any interested parties. This is not how to
	 * recover from errors or compute error messages. {@link ANTLRErrorStrategy}
	 * specifies how to recover from syntax errors and how to compute error
	 * messages. This listener's job is simply to emit a computed message,
	 * though it has enough information to create its own message in many cases.
	 *
	 * The {@link RecognitionException} is non-null for all syntax errors except
	 * when we discover mismatched token errors that we can recover from
	 * in-line, without returning from the surrounding rule (via the single
	 * token insertion and deletion mechanism).
	 *
	 * @param recognizer
     *        What parser got the error. From this
	 * 		  object, you can access the context as well
	 * 		  as the input stream.
	 * @param offendingSymbol
	 *        The offending token in the input token
	 * 		  stream, unless recognizer is a lexer (then it's null). If
	 * 		  no viable alternative error, {{{e}}} has token at which we
	 * 		  started production for the decision.
	 * @param line
	 * 		  The line number in the input where the error occurred.
	 * @param char_position_in_line
	 * 		  The character position within that line where the error occurred.
	 * @param msg
	 * 		  The message to emit.
	 * @param e
	 *        The exception generated by the parser that led to
	 *        the reporting of an error. It is null in the case where
	 *        the parser was able to recover in line without exiting the
	 *        surrounding rule.
	 */
	public abstract void syntax_error(Recognizer recognizer,
							Object offendingSymbol,
							int line,
							int char_position_in_line,
							string msg,
							RecognitionError e);

	/**
	 * This method is called by the parser when a full-context prediction
	 * results in an ambiguity.
	 *
	 * Each full-context prediction which does not result in a syntax error
	 * will call either {@link #report_context_sensitivity} or
	 * {@link #report_ambiguity}.
	 *
	 * When {@code ambig_alts} is not null, it contains the set of potentially
	 * viable alternatives identified by the prediction algorithm. When
	 * {@code ambig_alts} is null, use {@link ATNConfigSet#getAlts} to obtain the
	 * represented alternatives from the {@code configs} argument.
	 *
	 * When {{{exact}}} is {{{true}}}, //all// of the potentially
	 * viable alternatives are truly viable, i.e. this is reporting an exact
	 * ambiguity. When {{{exact}}} is {{{false}}}, //at least two// of
	 * the potentially viable alternatives are viable for the current input, but
	 * the prediction algorithm terminated as soon as it determined that at
	 * least the //minimum// potentially viable alternative is truly
	 * viable.
	 *
	 * When the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction
	 * mode is used, the parser is required to identify exact ambiguities so
	 * {{{exact}}} will always be {{{true}}}.
	 *
	 * This method is not used by lexers.
	 *
	 * @param recognizer the parser instance
	 *
	 * @param dfa the DFA for the current decision
	 *
	 * @param start_index the input index where the decision started
	 *
	 * @param stop_index the input input where the ambiguity was identified
	 *
	 * @param exact {{{true}}} if the ambiguity is exactly known, otherwise
	 * {{{false}}}. This is always {{{true}}} when
	 * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.
	 *
	 * @param ambig_alts the potentially ambiguous alternatives, or {{{null}}}
	 * to indicate that the potentially ambiguous alternatives are the complete
	 * set of represented alternatives in {{{configs}}}
	 *
	 * @param configs the ATN configuration set where the ambiguity was
	 * identified
	 */
	public abstract void report_ambiguity(Parser recognizer,
						 DFA dfa,
						 int start_index,
						 int stop_index,
						 bool exact,
						 BitSet? ambig_alts,
						 ATNConfigSet configs);

	/**
	 * This method is called when an SLL conflict occurs and the parser is about
	 * to use the full context information to make an LL decision.
	 *
	 * If one or more configurations in {{{configs}}} contains a semantic
	 * predicate, the predicates are evaluated before this method is called. The
	 * subset of alternatives which are still viable after predicates are
	 * evaluated is reported in {{{conflicting_alts}}}.
	 *
	 * This method is not used by lexers.
	 *
	 * @param recognizer the parser instance
	 *
	 * @param dfa the DFA for the current decision
	 *
	 * @param start_index the input index where the decision started
	 *
	 * @param stop_index the input index where the SLL conflict occurred
	 *
	 * @param conflicting_alts The specific conflicting alternatives. If this is
	 * {{{null}}}, the conflicting alternatives are all alternatives
	 * represented in {{{configs}}}. At the moment, conflicting_alts is non-null
	 * (for the reference implementation, but Sam's optimized version can see this
	 * as null).
	 *
	 * @param configs the ATN configuration set where the SLL conflict was
	 * detected
	 */
	public abstract void report_attempting_full_context(Parser recognizer,
									                    DFA dfa,
									                    int start_index,
									                    int stop_index,
									                    BitSet conflicting_alts,
									                    ATNConfigSet configs);

	/**
	 * This method is called by the parser when a full-context prediction has a
	 * unique result.
	 *
	 * Each full-context prediction which does not result in a syntax error
	 * will call either {@link #report_context_sensitivity} or
	 * {@link #report_ambiguity}.
	 *
	 * For prediction implementations that only evaluate full-context
	 * predictions when an SLL conflict is found (including the default
	 * {@link ParserATNSimulator} implementation), this method reports cases
	 * where SLL conflicts were resolved to unique full-context predictions,
	 * i.e. the decision was context-sensitive. This report does not necessarily
	 * indicate a problem, and it may appear even in completely unambiguous
	 * grammars.
	 *
	 * {{{configs}}} may have more than one represented alternative if the
	 * full-context prediction algorithm does not evaluate predicates before
	 * beginning the full-context prediction. In all cases, the final prediction
	 * is passed as the {{{prediction}}} argument.
	 *
	 * Note that the definition of "context sensitivity" in this method
	 * differs from the concept in {@link DecisionInfo#contextSensitivities}.
	 * This method reports all instances where an SLL conflict occurred but LL
	 * parsing produced a unique result, whether or not that unique result
	 * matches the minimum alternative in the SLL conflicting set.
	 *
	 * This method is not used by lexers.
	 *
	 * @param recognizer the parser instance
	 *
	 * @param dfa the DFA for the current decision
	 *
	 * @param start_index the input index where the decision started
	 *
	 * @param stop_index the input index where the context sensitivity was
	 * finally determined
	 *
	 * @param prediction the unambiguous result of the full-context prediction
	 *
	 * @param configs the ATN configuration set where the unambiguous prediction
	 * was determined
	 */
	public abstract void report_context_sensitivity(Parser recognizer,
					                			    DFA dfa,
					                			    int start_index,
					                			    int stop_index,
					                			    int prediction,
					                			    ATNConfigSet configs);
}
